\chapter{Análisis Teórico-Computacional de la propuesta de solución. Detalles de implementación}\label{chapter:proposal}
En el capítulo anterior se realizó un análisis del estado del arte, concluyendo con la
necesidad de implementar desde cero una aplicación de Android usando Flutter para su desarrollo, que cumpla con los requerimientos planteados.
Este capítulo estará enfocado en el marco teórico-computacional de la propuesta de
solución para este proyecto. Se abordarán temas que incluyen los detalles de la arquitectura seleccionada, la modelación de los datos del problema
y el análisis de los requerimientos funcionales de la aplicación. Se abordarán también las principales tecnologías utilizadas, así como, algunos detalles de implementación.
\section{Diagrama de casos de uso}\label{section:casosDeUso}
En esta sección se expondrán las acciones que puede realizar un usuario dentro de la aplicación, explicado a través de un diagrama de casos de uso
\footnote{Diagrama de casos de uso: Forma de diagrama de comportamiento UML(Unified Modeling Language o en español Lenguaje de Modelado Unificado) mejorado. Sirve para
    especificar la comunicación y el comportamiento de un sistema mediante su interacción con los usuarios
    y/u otros sistemas. Un diagrama que muestra la relación entre los actores y los Casos de Uso en un
    sistema.}
, teniendo en cuenta que solo existe un rol de usuario, Encuestador,
y tres grupos de acciones que se encapsulan en el diagrama por comodidad para el lector, Acciones de importación/exportación, Acciones en la pestaña 'Mapa' y Acciones en
la pestaña 'Registro'.
\pagebreak
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{Graphics/Capitulo 3/Diagrama_casos_de_uso.png}
    \caption{Diagrama de casos de uso de la aplicación Inventario.} % Título de la figura
    \label{fig:figura13}
\end{figure}
En la figura anterior(Ver figura \ref{fig:figura13}) se puden observar las diversas acciones que puede realizar un encuestador dentro de
la aplicación. Las mismas se explican a continuación:
\begin{itemize}
    \item \textbf{Ir a la pestaña 'Mapa'}: Al presionar en la pestaña nombrada de esta manera se abrirá la vista de Mapa. Por defecto esta es la vista que se muestra.
    \item \textbf{Ir a la pestaña 'Registro'}: Al presionar en la pestaña nombrada de esta manera se abrirá la vista de Registro o Formulario. Aquí se podrá introducir información relacionada con los predios, edificios y propiedades que se deseen.
    \item \textbf{Acciones de importación/exportación}
          Aqui se debe recalcar que estas funcionalidades diseñadas puramente por comodidad para los encuestadores, ya que se se colocan el mapa y las
          delimitaciones que se quieren mostrar, en las carpetas correspondientes no será necesario usar más nada, se mostrarán automáticamente en la aplicación.
          \begin{itemize}
              \item \textbf{Importar Mapa}: Esta opción abrirá una nueva ventana de selección de archivos, donde el usuario deberá seleccionar
                    un archivo con extensión '.mbtiles' para importarlo en la aplicación. Esto realizará una copia del archivo seleccionado hacia
                    la carpeta de mapas de la aplicación en el almacenamiento del dispositivo('CADIC/Maps'). Para que la importación surta efecto,
                    se deberá cambiar rápidamente de pestaña o cerrar y abrir la aplicación.
              \item \label{item:importaciongeojson}\textbf{Importar capa de Delimitaciones}: También abrirá una ventana de selección de archivos, pero esta vez esperando que
                    el usuario localice un archivo con extensión '.geojson'. Dentro del archivo deben encontrarse definiciones de polígonos, y
                    dentro de cada polígono, en el apartado de 'properties' podrá incluirse la etiqueta individual que se deseará mostrar para
                    cada polígono, esta se mostrará en el centro de cada polígono al renderizarse en el mapa. En el caso de una capa de polígonos
                    que representen predios, el archivo que contiene las delimitaciones deberá cumplir 2 resticciones para obtener
                    una correcta integración y funcionamiento con la aplicación. Una de estas restricciones es que el nombre termine de la siguiente manera:
                    \begin{mdframed}
                        (...)\_predios.geojson
                    \end{mdframed}
                    Por ejemplo: 'managua\_predios.geojson'. La otra restricción es que cada definición de polígono interna en el archivo,
                    tenga una propiedad 'localizacion' (sin tilde), con valor igual al número de localización correspondiente al predio que define.
                    De esta manera se importarán correctamente las delimitaciones, considerando cada archivo como una capa, y pintando de un color
                    diferente cada una de estas capas.

              \item \textbf{Exportar BD}: Esto exportará la BD hacia el directorio 'CADIC/Exportado'.
              \item \textbf{Limpiar BD}: Limpia la Base de Datos, solo dejando el nombre del encuestador registrado al iniciar la aplicación por primera vez.
          \end{itemize}
    \item \textbf{Acciones en la pestaña 'Mapa'}
          \begin{itemize}
              \item \textbf{Interactuar con el mapa}: En la pestaña 'Mapa', la funcionalidad primaria es la interacción con el mapa, lo que abarca desde
                    el acercamiento/alejamiento de la vista del mapa, como el desplazamiento de la vista horizontal y verticalmente. Esto se realiza con
                    los gestos clásicos de navegación por el mapa sobre la pantalla táctil del dispositivo.
              \item \textbf{Hacer click en uno de los predios}: Al cargar las delimitaciones de los predios, edificios y manzanas sobre el mapa,
                    los predios no solo se deberían mostrar como polígonos con borde de color rojo, sino que también deberán tener un marcador visualizado
                    como punto de color negro en su centroide. Al hacer click sobre uno de estos puntos en el mapa, automáticamente se accederá a la información
                    registrada del predio asociado al marcador, abriéndose la vista de la pestaña 'Registro' con los datos del predio si había sido registrado previamente.
                    \footnote{El centroide, también conocido como baricentro, es el centro geométrico de una figura o cuerpo. Representa el punto donde se concentraría toda
                        la masa si el objeto tuviera una distribución uniforme de masa. En otras palabras, es el punto de equilibrio de la figura. }

              \item \textbf{Acceder a la ubicación actual}: Si se presiona sobre el botón con un ícono de objetivo, la vista del mapa se centrará en
                    la localización actual del usuario.
          \end{itemize}
    \item \textbf{Acciones en la pestaña 'Registro'}
          \begin{itemize}
              \item \textbf{Cambiar el predio que se está visualizando/editando}: Por defecto en la vista del Formulario, el número de Localización no se puede variar,
                    pero al lado de este campo inhabilitado, se encontrará una casilla para marcar, la cual si está en efecto marcada, permitirá cambiar el número de
                    localización, lo que concede acceder manualmente a la información de un predio con solo introducir su identificador de localización.
              \item \textbf{Editar/rellenar campos del formularios}: Sin profundizar aún mucho en el tema, cabe mencionar que los formularios son reactivos, y por lo tanto,
                    varias acciones que se realicen en la aplicación, tendrán repercución en lo que se muestra y lo que no del formulario.
              \item \textbf{Guardar un formulario}: Un formulario no se registrará en la Base de Datos si no se presiona el botón de "Guardar".
              \item \textbf{Editar edificio/propiedad}: Si el número de localización actual del formulario, refiere a un predio ya registrado en la base de datos, en caso de
                    que este predio tenga edificios ya registrados, igualmente se mostrarán en una lista de elementos visuales dentro del subformulario Edificio. Luego, la manera
                    de editar un edificio ya existente, es presionando sobre el elemento visual que lo representa con el identificador 'Ed' acompañado de su número de edificio. Este cambiará
                    de color y de esta manera se sabrá que este edificio está siendo editado. Los campos que hayan sido rellenados previamente del edificio se visualizarán por si se
                    desea editarlos. En la figura \ref{fig:edicionFormulario1} se puede ver el caso de un predio con 3 edificios, donde se están editando los valores del edificio 2\\
                    \begin{figure}[h]
                        \centering
                        \includegraphics[scale=1]{Graphics/Capitulo 3/edicion_formulario_2.png}
                        \caption{Edición del edificio 2 perteneciente a un predio con 3 edificios.} % Título de la figura
                        \label{fig:edicionFormulario1}
                    \end{figure}\\
                    Un comportamiento similar ocurre con la relación edificio-propiedades. Cuando un edificio esté seleccionado, y se aprecie con un color verde claro, como
                    anteriormente se dijo, este está seleccionado, esto significa que se podrá editar y al mismo tiempo el formulario mostrará un nuevo subformulario 'Propiedades'
                    que mostrará las propiedades asociadas al edificio seleccionado, como una lista de elementos visuales que representan a cada propiedad mostrando una letra 'P' junto
                    al Número de local de cada propiedad, de manera similar a como lo hace el subformulario 'Edificio' con los edificios del predio seleccionado.
                    Para editar una propiedad se hará igual a como se edita un edficio, presionando encima del elemento visual que le identifica. De igual manera al hacer esto, el elemento visual
                    presionado cambiará a un color verde claro, indicando que la propiedad que representa está siendo editada, mostrando en el subformulario Propiedad los valores guardados
                    de la propiedad en cuestión para cada campo.
              \item \textbf{Eliminar edificio/propiedad}: A la derecha de cada elemento visual que representa tanto una propiedad como los de cada edificio, se observará una pequeña cruz
                    la cual al ser presionada hará que se elimine dicha propiedad o dicho edificio respectivamente. Luego de haber eliminado la entidad en cuestión, en caso de haber presionado
                    esta opción por error, será posible revertir esto antes de los 5 segundos de haber eliminado la entidad presionando "Deshacer" en una barra auxiliar que aparecerá justo luego de
                    haber eliminado.
              \item \textbf{Marcar predio como visitado}: Esta es una de las funcionalidades más útiles visualmente para un encuestador al estar en una inspección. Al final del formulario en la pestaña
                    de Registro, habrá un botón con el texto "Predio Visitado"; al presionarlo, este hará que visualmente el predio en cuestión cambie de color en sus border, o sea, que se coloree
                    de verde, y que se rellene con un color verde un poco mas claro y con tono trasparente. Esto será una herramienta que se use meramente por comodidad, no se guardará información
                    referente a este cambio en la Base de Datos ni en los archivos de delimitaciones.
          \end{itemize}

\end{itemize}
\section{Propuestas de Arquitectura}
Luego de investigar varias arquitecturas propicias para el desarrollo en Flutter, valorarlas y pensar en cuál sería la ideal para un proyecto no tan grande,
teniendo en cuenta arquitecturas modernas y otras no tan modernas pero utilizadas comúnmente en proyectos de Flutter, se llegó a la conclusión de que se utilizaría
una arquitectura Modelo-Vista-Modelo de Vista (MVVM por sus siglas en inglés)\cite{MVVM}, una variación moderna de la arquitectura Modelo-Vista-Controlador(MVC) \cite{MVC},
con ciertos ajustes y adaptaciones mínimas dado el corto tiempo del que se dispone y los patrones de desarrollo y arquitectura de Flutter en si.
\subsection{Aruitectura Modelo-Vista-Modelo de Vista}
El patrón MVVM fue introducido por John Gossman en 2005 mientras trabajaba en Microsoft, y fue diseñado inicialmente para su uso
con Windows Presentation Foundation (WPF) y Silverlight. Desde entonces, MVVM ha sido adoptado en diversas plataformas y frameworks como Flutter,
debido a sus beneficios en la separación de responsabilidades y la mejora de la testabilidad.
Este patrón de arquitectura o simplemente arquitectura, busca separar estrictamente la Interfaz de usuario de la lógica de negocio y de presentación, estableciendo un componente
intermedio como lo hace la arquitectura MVC con el Controlador, pero en este caso con el Modelo de Vista o ModelView. La principal diferencia entre estas dos arquitecturas
es que en MVC se trata de separar el acceso a los datos mediante el componente Controlador, pero en MVVM se trata de separar la lógica de negocio de la UI a través del componente
Modelo de Vista, el cual mantendrá el estado de los datos que se muestran en la Vista y será reactivo al cambio de la misma, haciendo variaciones internas y dejando los datos en
un formato listo para ser mostrado nuevamente, dejando la responsabilidad de los datos en si y el acceso a ellos, al componente Modelo, por lo que esta arquitectura está orientada
a la claridad y limpieza de la Vista o UI. A continuación, se resumen y exponen las resposabilidades de cada componente de esta arquitectura, pudiendo apoyarse también en en diagrama
de la figura \ref{fig:figura14}:

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.35]{Graphics/Capitulo 3/modelo MVVM.png}
    \caption{Diagrama de Arquitectura 'Modelo-Vista-Modelo de Vista'.} % Título de la figura
    \label{fig:figura14}
\end{figure}

\begin{itemize}
    \item \textbf{Modelo}: Contiene las entidades de dominio (datos). Contiene las reglas de negocio. Accede a bases de datos, servicios remotos, etc.
    \item \textbf{Vista}: Solo se encarga de mostrar datos. Observa al ViewModel. Notifica al ViewModel de los eventos de usuario.
    \item \textbf{Modelo de Vista}:
          \begin{itemize}
              \item Contiene la lógica de presentación.
              \item Expone los datos a la vista en un formato listo para mostrar.
              \item Responde a eventos de la vista.
              \item Hace la comunicación con el modelo.
              \item Maneja el estado de la vista.
              \item No tiene referencia directa a la vista.
          \end{itemize}

\end{itemize}
\subsection{Arquitectura MVVM aplicada a la propuesta de solución}
En la siguiente imagen se muestra la estructura del proyecto:
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{Graphics/Capitulo 3/estructura_del_codigo.png}
    \caption{Estructura del código.} % Título de la figura
    \label{fig:figura15}
\end{figure}

En la figura anterior (Ver figura \ref{fig:figura15})se pueden apreciar las diferentes capas de la arquitectura MVVM bien definidas,
representadas por las carpetas 'Model', 'View' y 'ViewModel' que contienen la parte del código relacionada con la capa de arquitectura
que su nombre indica:\\\\
\textbf{Model}\label{item:Model}\\
Aquí se encuentra la capa que abarca los datos y el acceso a ellos. Se hace uso de la librería sqflite \cite{sqflite} como mediador de comunicación
con bases de datos SQLite. Se encierra el modelo de datos en una jerarquía de clases reutilizable y expandible que tiene como padre la clase abstracta \textbf{InventarioDbTable},
de la cual las clases que representan las tablas del modelo de datos del problema heredan, obligándoles a implementar propiedades y métodos que proporcionarán
el formato de los datos que requiere sqflite para insertar en sus tablas correspondientes. Estas clases asociadas a las tablas de la Base de Datos
son \textbf{Predio}, \textbf{Edificio} y \textbf{Propiedad}.
\\\\
\textbf{View}\\
El componente Vista está dividido en dos partes, las pantallas o 'Screens' y los 'Widgets'
\footnote{Los widgets son básicamente componentes de Flutter utilizados para crear la interfaz de usuario de
    la aplicación}.
Existen solo dos pantallas en este caso, la pantalla del mapa sin conexión, que es donde se hace uso de las librerías flutter\_map y flutter\_map\_mbtiles para
obtener el componente que renderiza el mapa a partir de un archivo con formato/extensión ".mbtiles", y la pantalla del formulario, donde se hace uso de la gran
cantidad de Widgets predefinidos que posee Flutter para los diversos campos de los subformularios. Además se definen subdirectorios para separar componentes que se
usan en ambas pantallas. Las partes que se usan para conformar la pantalla del formulario se encuentran dentro del subdirectorio \textbf{Form Sections} y son los
subformularios Predio, Edificio y Propiedad, que usan individualmente componentes/widgets de Flutter para los campos que se asocian con los datos de cada una de
las tablas que representan. Al mismo tiempo, la funcionalidad que se declara dentro del subdirectorio \textbf{Map utilities} es la declaración de un widget
que representa una capa de delimitaciones, el cual se encarga de filtrar los polígonos que representan predios y calcular los centroides y pintarlos\\
Por otra parte, los Widgets que se definen son para el uso mayormente en la pantalla del formulario. Algunos de ellos son campos de formulario personalizados que
ofrecen una validación y son reactivos de acuerdo a lo que se necesita. Estos son los campos de fecha e imagen, además de algunos widgets que ayudan con el flujo
de procesos de la interfaz visual.
\\\\
\textbf{ModelView}\\
En este componente de la arquitectura está ubicado mayormente el estado de las variables de los formularios y la validación de los mismos. Los formularios se encargan
desde el componente Vista de mantener los datos de su controlador correspondiente actualizados a medida que cambian según la actividad del usuario en la interfaz,
y al usuario presionar en un boton de Guardar, el controlador correspondiente del componente ModelView se encarga de validar los datos, enviárselos al componente Modelo
para que los guarde en la base de datos, y luego de eso, haciendo uso del propicio patrón de utilización de funciones de callback\footnote{Funcion de callback es una
    forma de ejecutar una función en un punto del código deseado confiándole dicha función a un método u objeto pasándola como parámetro} de Flutter, se actualiza la interfaz
visual en consecuencia. Cabe destacar que por motivos de organización cada subormulario tiene su propio controllador en la capa de ModelView.
\\
\section{Modelo de Base de Datos} \label{section:dataModel}
Dada la naturaleza del problema: desarrollo en Android, desconexión de internet; y la naturaleza de Flutter, se escogió trabajar con el sistema gestor de bases de datos SQLite,
que ofrece simplicidad y una buena integración con Flutter a través de la librería sqflite, que a pesar de ser desarrollada por la comunidad, es un paquete muy utilizado y
testeado en ambientes de desarrollo. Por otra parte, solo hay que enfocarse en el modelado de las entidades y relaciones presentes en el problema, ya que una vez construida
la base de datos localmente, esta se exporta como archivo y se consume por un servicio externo, el cual está fuera del margen de esta tesis.\\
También es importante mencionar que se hizo una variación en el concepto de modelo de datos propuesto inicialmente por el cliente, ya que existían conceptos redundantes que podían
causar confusión y falta de claridad, pensando en primera instancia en los propios encuestadores, que son los futuros usuarios que utilizarán la aplicación final. En el modelo propuesto
por el cliente existían cinco módulos los cuales poseen una entidad sobre la cual recogen información, y definen la información a recoger sobre su entidad correspondiente.
Los cinco módulos propuestos por el cliente y las respectivas entidades sobre las que recogen información (también pudiendo ser visualizados en la tabla \ref{tab:modulosAnteriores}) son:
\pagebreak

\begin{table}[h!]
\centering
\caption{Módulos comprendidos en el modelo de datos propuesto por el cliente}
\label{tab:modulosAnteriores} % Etiqueta para referenciar la tabla más adelante
\begin{tabular}{|r|l|}
    \toprule
    \textbf{Módulo}                     & \textbf{Entidad que encuesta}                      \\
    \midrule
    Terreno                             & Información sobre el Predio                        \\
    Construcción                        & Información sobre los edificios del Predio         \\
    Medidores Eléctricos                & Información sobre los edificios del Predio         \\
    Edificación                         & Información sobre los edificios del Predio         \\
    Uso de Suelo y Patentes Comerciales & Información sobre las propiedades de cada Edificio \\
    \bottomrule % Línea horizontal inferior (requiere booktabs)
\end{tabular}
\end {table}
Por ende, como se puede observar, aquí existen 3 módulos de datos referenciando a la misma entidad, Edificio, por lo que se decidió factorizar estos módulos, agrupándolos en
\textbf{Predio}, \textbf{Edificio}, \textbf{Propiedad} y \textbf{Encuestador}.
Luego, la base de datos que modela el problema es bastante simple; en la figura \ref{fig:figura16} se muestra el diagrama Entidad-Relación del modelo de datos:
% \pagebreak
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{Graphics/Capitulo 3/DiagramaER.png}
    \caption{Diagrama Entidad-Realción del modelo de datos.} % Título de la figura
    \label{fig:figura16}
\end{figure}
Cabe destacar que por motivos de optimización, en los campos de selección de una lista fija de valores como por ejemplo lo es el caso de 'materialFachada' en la entidad Edificio, se almacena solo un valor entero que representa el índice de
la lista asociado con el valor que representa. Por ejemplo en este caso si el edificio que se está encuestando tiene un material de fachada prefabricado, como en la lista de posibles materiales en la fachada, este valor es asociado con el índice 2,
pues ese sería el valor que tomaría este campo, en lugar de almacenar el texto completo 'Prefabricado'. Tener en cuenta también que no siempre los índices que correponden al valor siguen una secuencia, por ejemplo en el propio campo de materialFachada,
se tiene el valor 'No visible' cuyo índice asociado sería 999, teniendo esta lista solamente 8 elementos. En cada campo de selección se especificará la lista de valores con sus índices numéricos asociados.
\subsection{Predio}
En el modelo de datos, \textbf{Predio} es la única entidad fuerte, o sea, la existencia de un predio no depende de la existencia de ninguna otra entidad del modelo. Estos son los campos/variables que incluye una tupla de Predio:\\\\
\underline{idPredio}: Campo de tipo entero de 10 cifras. LLave primaria de la entidad \textbf{Predio}. Es el número de localización del predio, el cual es único así que puede usarse como identificador.\\
\underline{nivelPredio1}, \underline{nivelPredio2} y \underline{nivelPredio3}: Campos numéricos, aceptan decimales, los cuales se refieren a "la
diferencia de altura del acceso principal del edificio al punto de intersección entre la acera y el vértice"\\
\underline{acera}: Campo de tipo entero que dice el estado de la acera de un predio. Representa el índice de la opción que se escoja de la siguiente lista de opciones: [0: 'No existe', 1: 'Bueno', 2: 'Regular', 3: 'Malo']. Por ejemplo,
si este campo tiene valor 1 en un predio, significa que el estado de la acera de ese predio es \textbf{bueno}\\
\underline{anchoAcera}: Campo numérico que acepta decimales. Representa el ancho de acera que hay frente al predio.\\
\underline{observacionesTerreno}: Texto describiendo las observaciones hechas por el encuestador sobre el terreno del predio.\\\\
\subsection{Edificio}
Edificio es una entidad débil, la cual posee una relación de dependencia de identificación con la entidad Predio, o sea, que una tupla de Edificio depende de la existencia de una tupla de Predio.
Estos son los campos/variables en la entidad Edificio:\\\\
- \underline{idPredio}, \underline{noEdificio}: Llaves primarias, ambas de tipo entero. idPredio a su vez es clave foránea y apunta hacia la entidad Predio.\\
- \underline{distrito}: Campo de tipo entero. Representa el índice del distrito al cual pertenece el edificio, de la lista de distritos siguiente: [1: 'Carmen', 2: 'Merced', 3: 'Hospital', 4: 'Catedral', 5: 'Zapote', 6: 'San Francisco', 7: 'Uruca', 8: 'Mata Redonda', 9: 'Pavas']\\
- \underline{cantidadPisos}: Campo de tipo entero. Cantidad de pisos del edificio.\\
- \underline{cantidadSotanos}: Campo de tipo entero. cantidad de pisos por debajo del nivel de la acera.\\
- \underline{antejardin}: Campo de tipo entero. Evalúa la existencia de al menos 1/3 de área verde en la zona del antejardín. Representa un índice asociado a la lista [0: 'No existe', 1: 'Si existe', 996: 'En construcción', 998: 'No aplica']\\
- \underline{materialFachada}: Campo de tipo entero. Evalúa el material predominante en la fachada del edificio. Representa el índice del material que le corresponde de la lista: [1: 'Bloques y Concreto', 2: 'Prefabricado', 3: 'Vidrio y Metal', 4: 'Ladrillo', 5: 'Madera', 6: 'Mixto', 998: 'No aplica', 999: 'No visible']\\
- \underline{canoasBajantes}: Campo de tipo entero. Asociado a un índice de la lista: [0: 'No existe', 1: 'Cumple', 2: 'No cumple', 998: 'No aplica']\\
- \underline{observacionesEdificacion}: Texto describiendo las observaciones acerca de la edificación.\\
- \underline{estadoInmueble}: Campo de tipo entero. Asociado a un índice de la lista: [1: 'Óptimo', 2: 'Muy Bueno', 3: 'Bueno', 4: 'Intermedio', 5: 'Regular', 6: 'Deficiente', 7: 'Malo', 8: 'Muy Malo', 9: 'Demolición', 998: 'No Aplica']\\
- \underline{imagenConstruccion}: Campo de tipo bytes que almacena una imagen referente a la construcción del edificio.\\
- \underline{cantidadMedidores}: Campo de tipo entero. Catidad de medidores eléctricos en el edificio.\\
- \underline{observacionesMedidores}: Texto describiendo las observaciones acerca de los medidores del edificio.\\
- \underline{observacionesConstruccion}: Texto describiendo las observaciones acerca de la construcción del edificio.\\
\subsection{Propiedad}
Propiedad es una entidad débil también, la cual tiene relación de dependencia de identificación con la entidad Edificio, y por ende, con la entidad Predio, es decir que una propiedad depende de la existencia de un edificio y por ende de un predio.
Aquí se verán campos de tipo booleanos, o sea de Verdadero o Falso, que permitirán la existencia de otros campos. Por ejemplo, si el campo booleano 'tienePatenteLicores' está en falso, el campo 'numeroPatenteLicores' no se podrá rellenar. En el
caso del campo booleano 'tienePermisoSalud', tres campos dependen de su valor para ser rellenados o no. También existen campos de selección múltiple, los cuales serán almacenados en un campo de tipo texto, que incluya los valores de la selección
separados por coma(','). Además, especificar que el campo de fecha 'fechaVigenciaPermisoSalud' en el formulario se tendrá la posibilidad de escoger desde un calendario y se verá la fecha en un formato bien definido, pero al almacenarse en la
base de datos, este será recogido como un número entero, que tendrá el formato 'AAAAMMDD'; y por último, también existen campos inhabilitados, o sea, que no podrán ser rellenados por los encuestadores. Estos campos se dejarán en la base de datos
para que sea posible añadirlo luego fácilmente por la entidad encargada en caso de querer hacerlo. \\
- \underline{idPredio}, \underline{noEdificio}, \underline{noLocal}:
- \underline{nivelPiso}:  Campo de tipo texto, en el que se debe anotar el número de piso en donde se encuentra localizada la actividad. Si es más de un piso, deberá anotarse el
rango de los pisos en que está localizado, ejemplo, "1-7" (piso 1 al piso 7), o si la actividad también se desarrolla en un sótano, entonces seria, por ejemplo "$ $-1-4" (sótano 1 al piso 4). \\
- \underline{actividadPrimaria}: Campo de tipo texto, en donde se anotará la actividad principal encontrada. \\
- \underline{actividadComplementaria}:  Campo de tipo texto, en donde se anotará la actividad menos predominante.\\
- \underline{estadoNegocio}: Campo de tipo texto que se basa en una selección múltiple que evaluará la situación actual del negocio. La lista de opciones a escoger es: ['En operación', 'Cierre temporal', 'Desocupado con Rótulo SE ALQUILA', 'Cierre total', 'Ha modificado la actividad autorizada(EXPRESS u otra actividad)].\\
- \underline{nombreNegocio}:  Campo de tipo texto, en el cual se anotará el nombre de fantasía del negocio, ubicado en la publicidad (rotulo, vallas, ventanería, etc.). \\
- \underline{cantidadParqueos}: Campo numérico, en donde se anotará la cantidad de espacios de parqueos observada con que cuenta el inmueble. \\
- \underline{documentoMostrado}: Campo de tipo entero. Representa el índice que asocia el tipo de documento presentado que represente la patente de la actividad de la siguiente lista: [1: 'Certificado Patente', 2: 'Recibo al día(Menos de dos meses de atraso)', 3: 'Recibo atrasado(Con más de dos meses de atraso)', 4: 'Certificado Trámite "$ $CT". Indicar el número', 5: 'No muestra documentos de patente']. \\
- \underline{nombrePatentado}: Campo de tipo texto, en el cual se deberá anotar el nombre de quien está en la patente comercial del negocio. \\
- \underline{numeroPatenteComercial}: Campo de tipo entero. Número de patente comercial o código específico en casos señalados puntuales. \\
- \underline{cedulaPatentado}: Campo de tipo entero, en el cual se anotará el número de cedula que se muestra en el certificado o recibo de la patente. \\
- \underline{nombreActividadPatente}: Campo de tipo texto en donde se anotará la actividad que aparece en la patente en un lugar específico. \\
- \underline{tieneMasPatentes}: Campo de tipo booleano. \\
- \underline{numeroPatente\_2}: Campo de tipo entero. Este campo estará presente solo si el campo 'tieneMasPatentes' está marcado. \\
- \underline{tienePermisoSalud}: Campo de tipo booleano. \\
- \underline{numeroPermisoSalud}: Campo de tipo entero. Este campo estará presente solo si el campo 'tienePermisoSalud' está marcado. \\
- \underline{fechaVigenciaPermisoSalud}: Campo de tipo entero que almacena la fecha en el formato 'AAAAMMDD'. Este campo estará presente solo si el campo 'tienePermisoSalud' está marcado. \\
- \underline{codigoCIIUPermisoSalud}: Campo de tipo texto. Código CIIU\footnote{El Código CIIU, o Clasificación Industrial Internacional Uniforme, es un sistema de clasificación de actividades económicas a nivel mundial. Se utiliza para agrupar y categorizar las diferentes actividades que realizan las empresas y personas naturales, facilitando así la recopilación y análisis de datos estadísticos a nivel nacional e internacional} del permiso de salud: código que aparece en el permiso de salud de la actividad económica que se desempeña. Este campo estará presente solo si el campo 'tienePermisoSalud' está marcado. \\
- \underline{seTrataDeLocalMercado}: Campo de tipo booleano. \\
- \underline{numeroLocalMercado}: Campo de tipo entero. Este campo estará presente solo si el campo 'seTrataDeLocalMercado' está marcado. \\
- \underline{tienePatenteLicores}: Campo de tipo booleano \\
- \underline{numeroPatenteLicores}: Campo de tipo entero. Este campo estará presente solo si el campo 'tienePatenteLicores' está marcado. \\
- \underline{areaActividad}: Campo de tipo entero. Representa el índice asociado a una de las opciones de la siguiente lista: [1: 'Menos de 50m²', 2: '51 a 100m²', 3: '101 a 200m²', 4: '200 a 400m²', 5: '400 a 1000m²', 6: 'Más de 1000m²', 998: 'No aplica', 999: 'No visible']. \\
- \underline{telefonoPatentado}: Campo de tipo entero, con el número telefónico del propietario del inmueble. \\
- \underline{correoElectronico}: Campo de tipo texto. Correo del propietario. \\
- \underline{cantidadEmpleadosAntesCovid}: Campo de tipo entero. \\
- \underline{cantidadEmpleadosActual}: Campo de tipo entero. \\
- \underline{afectacionesCovidPersonalDesempennoEmpresa}: Campo de texto. Es conformado por un campo de selección múltiple de entre las opciones de la siguiente lista: ['Despido de empleados', 'Reducción jornada laboral', 'Suspensión del contrato laboral', 'Se adelantaron vacaciones', 'Se empezó a trabajar por turnos', 'Se aumentaron las jornadas', 'Se implementó modalidad de teletrabajo']. \\
- \underline{afectacionesCovidSobreVentas}: Campo de texto. Es conformado por un campo de selección múltiple de entre las opciones de la siguiente lista: ['Ingresó (0) ante la afectación de una orden sanitaria', 'Reducción de los ingresos entre un 50-90\%', 'Reducción de los ingresos entre un 20-50\%', 'Se mantuvieron dentro de lo esperado', 'Aumentaron', 'Ninguna', 'NS-NR'] \\
- \underline{codigoCIIUActividadPrimaria}: Campo de tipo texto. Inhabilitado. \\
- \underline{codigoCIIUActividadComplementaria}: Campo de tipo texto. Inhabilitado \\
- \underline{observacionesPatentes}: Texto describiendo las observaciones acerca de la construcción del edificio. \\
- \underline{imagenDocumentoLegal}: Campo de tipo bytes que almacena una imagen que capture el documento legal mostrado por la entidad. \\

\section{Tecnologías y librerías utilizadas}
\subsection{Dart}
Como base decisiva, tanto para la fácil integración de la arquitectura pensada, como para la organización y productividad a la hora de depurar el código del proyecto,
es imprescindible mencionar a Dart, un lenguaje orientado a objetos, fuertemente tipado aunque con inferencia de tipos, basado en clases, con Garbage Collector
\footnote{El Garbage Collector es un sistema automatizado que libera la memoria que ya no está siendo utilizada por un programa}
y una sintaxis al estilo C, que puede compilar tanto a código nativo como a JavaScript. Admite interfaces, mixins, clases abstractas, genericidad, entre otras maravillosas cualidades. \cite{dartOficial}
\subsection{Paquete geolocator}
Este paqute se utilizó para la facilitación de la funcionalidad de obtener la geolocalización en tiempo real del dispositivo Android sobre el que está corriendo la aplicación.
Este paquete ofrece una gran facilidad en el manejo de los permisos de geolocalización y clases y métodos bastante útiles para el trabajo con posiciones geográficas.
\subsection{Paquete latlong2}
LatLong es un paquete que incorpora Geodesia y Cálculos Geográficos para Dart,
proporciona una biblioteca liviana para el uso de proyecciones LatLong, o sea latitud y
la longitud, las unidades que representan las coordenadas en el sistema de coordenadas
geográficas. \cite{latlong2}
\subsection{Paquetes file\_picker e image\_picker}
File Picker es un paquete para iOS y Android que permite usar el explorador de archivos nativo para seleccionar uno o varios archivos con soporte de filtrado de extensiones,
de igual manera Image Picker es un plugin de Flutter que permite seleccionar archivos,
en este caso imágenes de la biblioteca de imágenes y tomar nuevas fotos con la cámara.

\subsection{Paquete permission\_handler}
Este paquete fue clave en el manejo de permisos de escritura de archivos. La aplicación para iniciarse, por comodidad y organización debe obtener los permisos de manejo y escritura sobre el sistema de archivos
del sistema de archivos del dispositivo, y en Android, los permisos de escritura en las últimas versiones han cambiado mucho, volviéndose una odisea tener en cuenta el tipo de permiso que se debe pedir
según la versión de sdk o de sistema operativo que tenga el dispositivo. Este paquete es bastante útil para el manejo de permisos, incluyendo incluso funciones que redireccionan al usuario hacia los ajustes del
dispositivo para que concedan el permiso, en caso que no haya otra opción.
\subsection{Paquete image}
En SQLite, el almacenamiento de imágenes tiene un problema, y es que el tamaño de archivos multimedia en campos 'BLOB'
\footnote{Un campo BLOB, o Objeto Binario Grande, es un tipo de campo en bases de datos utilizado para almacenar datos binarios de gran tamaño, como imágenes, audio, video o documentos}
tiene un límite de tamaño. Se sugiere almacenar en campos BLOB archivos de no más de 5mb. Por esta razón fue necesario usar el paquete image\cite{image} para procesar y comprimir las imágenes mayores de 1.8mb, que ya sería un tamaño no tan prudente
para un archivo a ser almacenado en un campo BLOB de SQLite.
\section{Detalles de implementación}
En esta subsección se explicará de cara al desarrollador, la implementación de cada uno de los elementos visuales de los subformularios en la capa o componente View, y la relación con sus controladores en la capa o componente ModelView. También se explicará la estructura del
modelo a nivel de código y la jerarquía de clases utilizada.\\\\
\subsection{Subformularios}
Como ya se mencionó, existen varios subformularios que integran la funcionalidad de Registro en la aplicación Inventario. Ellos son Predio, Edificio y Propiedad. Estos solo están integrados por la parte visual de sus respectivos campos, y una mínima implementación
de funciones pequeñas de validación de campos, como comprobaciones de nulidad, o si el valor que se introdujo en un campo es entero, o verificar la cantidad de cifras de un número no es correcta. En la siguiente figura se presenta un fragmento del código del subformulario
Predio donde se puede ver parte de la implementación de algunos campos del mismo(ver Figura \ref{fig:figura17}).

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{Graphics/Capitulo 3/formulario_predio.png}
    \caption{Fragmento de la implementación del subformulario Predio} % Título de la figura
    \label{fig:figura17}
\end{figure}

Como ya se analizó en el epígrafe \ref{section:dataModel}, se tienen varios predios, donde cada uno de estos predios puede contener varios
edificios, y cada uno de estos edificios puede contener varias propiedades. Luego para agregar un edificio a la base de datos se debe prefijar un predio
y para agregar una propiedad a la base de datos se debe prefijar un predio y un edificio dentro de ese predio.\\
A nivel global, durante toda la ejecución, se mantiene un objeto de manera estática que tiene tres valores enteros, que también pueden ser null.
Esta variable se llama 'formGlobalStatusWrapper' o simplemente 'formGlobalStatus', y los 3 valores enteros que guarda son los identificadores del predio,
el edificio y la propiedad que se estén editando. Por ejemplo, si:
\begin{itemize}
    \item formGlobalStatus['idPredio'] = 1000000001, formGlobalStatus['noEdificio'] = null y formGlobalStatus['noLocal'] = null: Significa que se está trabajando sobre el
          predio con ese número de localización, pero no se está editando ningún edificio existente, y por ende ninguna propiedad.
    \item formGlobalStatus['idPredio'] = 1000000001, formGlobalStatus['noEdificio'] = 1 y formGlobalStatus['noLocal'] = null: Significa que se está trabajando sobre el edificio
          número 1 del predio 1000000001
    \item formGlobalStatus['idPredio'] = 1000000001, formGlobalStatus['noEdificio'] = 1 y formGlobalStatus['noLocal'] = 34: Significa que se está trabajando sobre la propiedad 34 del edificio
          número 1 del predio 1000000001.
\end{itemize}
Por lo tanto estas tres variables van a definir básicamente sobre qué entidades se están trabajando. Ahora, haciendo uso del patrón de utilización de funciones callback, se realizó un sistema de
eventos, donde se permite la posibilidad de, dentro de esta estructura 'formGlobalStatus' suscribirse a los eventos de asignación de las variables formGlobalStatus['idPredio'], formGlobalStatus['noEdificio'] y formGlobalStatus['noLocal']
a funciones que, según qué predio, edificio, o propiedad esté activa, renderizar el formulario en consecuencia.
\subsection{Reactividad de los formularios}
Luego, cada subformulario, tiene su propio controlador, declarado como una variable. El controlador,
que forma parte de la capa ModelView, estaría abstraído de lo que ocurre con la interfaz del formulario. El controlador simplemente guardaría el estado
de las variables. Cada formulario, al sí tener control de su estado, puede acceder a él para en base a si hay algún cambio, renderizar su interfaz visual en consecuencia.
Esto se logra haciendo uso del principio de llaves de widgets en Flutter, que plantea que si una llave de un widget cambia, este widget deberá ser renderizado nuevamente
Por ejemplo, en la Figura \ref{fig:figura17} podemos observar como cada uno de los campos de Predio, obtiene el valor del estado de su variable, y lo establece como
valor inicial del campo y también lo establece como llave a ese campo, diciéndole a Flutter que cuando este valor cambie, debe cambiar también la interfaz visual. Esto provoca que
al cambiarse el estado global de la aplicación(variable formGlobalStatus), se desencandenen una serie de acciones al intentar renderizar los 3 subformularios:
\begin{enumerate}
    \item Cada subformulario inicializa su controlador
    \item El Controlador de Predio le pide al Modelo que busque el predio con número de localización igual a formGlobalStatus['idPredio']
    \item El Controlador de Edificio le pide al Modelo que busque todos los Edificios que tienen como número de localización: formGlobalStatus['idPredio'] para asi tenerlos listos para la UI.
    \item El Controlador de Edificio, en caso de que formGlobalStatus['noEdificio] != null, inicializa su estado con los datos del edificio que esté dentro del predio con número de localización igual a
          formGlobalStatus['idPredio'] y con número de Edificio igual a formGlobalStatus['noEdificio'].
    \item $\cdots$
    \item El View de Edificio, al comenzar a renderizarse, accede al estado de su Controlador y autorrellena el formulario en caso de tener variables con valores. Además muestra la lista de edificios del predio en el tope del formulario como elementos visuales para ser seleccionados
    \item $\cdots$
\end{enumerate}
El mismo proceso ocurre con Propiedad y su Controlador, pero esta vez chequeando la variable formGlobalStatus['noLocal'] y encontrando las propiedades que pertenezcan al edificio con número formGlobalStatus['noEdificio']\\
\subsection{Validación de formularios}
La validación de los formularios ocurre en los respectivos controladores, o sea, en la capa ModelView. El botón de la UI invoca la función del controlador 'validateForm', este al tener la llave del formulario del view,
invoca el método validate() y se validan todos los campos del formulario, si son válidos, se procede a ver si existe un caso de sobrescritura, o de añadir un edificio sobre un predio que aún no está en la Base de Datos, etc,
y en caso de no haber problemas, se le pasa la tupla al modelo en forma de clase y el modelo lo convierte en un Map<String, dynamic> y lo introduce en la base de datos, el Model responde al ModelView que si se pudo guardar la tupla,
por ende el ModelView le deja saber al View lo mismo, y este último le muestra un mensaje al usuario de confirmación de operación.
% \subsection{Restricciones y visibilidad de campos de los formularios}

\subsection{Exportación e importación de archivos}
La única forma de mostrar mapas sin conexión a Internet con Flutter(sin descarga inicial siquiera) es con la librería flutter\_map\_mbtiles, y esta lee los archivos de mapas en formato '.mbtiles' por lo que fue obligatorio el uso de este tipo de formato de archivo de mapa
sqlite. Luego, para la importación de capas de delimitaciones encima del mapa base, se escogió el formato gegojson por la claridad que ofrece, además de la cantidad de herramientas que existen hoy en día que crean polígonos
de una manera rápida y efectiva, además de la facilidad de lectura y extracción de datos, leyendo estos archivos como json con librerías built-in de Dart. Ya se expusieron las razones de por qué se escogió SQLite como sistema gestor de bases de datos.
Revisar el formato de entrada del las delimitaciones en archivos geojsonen a inicios de este capítulo(Ver \ref{item:importaciongeojson}) para su correcta importación
\subsection{Extensión del código}
En esta subsección se hablará un poco más de la capa Model y de como extender el modelo de datos en caso que se desee, ya que en realidad los datos son la característica principal de una aplicación de categoría SIG.
La capa Model esta compuesta por 3 archivos, 'db\_debug.dart', 'db\_general\_management.dart' y 'file\_management.dart', pero en realidad donde se concentra el diseño del modelo es en 'db\_general\_management.dart'. Se diseñó una jerarquía de clases con el objetivo de
entregar un proyecto expansible y reutilizable, la cual consta, como ya se explicó a grandes rasgos en \ref{item:Model} de una clase abstracta 'InventarioDbTable' que tiene la implementación de las operaciones de eliminación, actualización e inserción, basados en propiedades que debe
implementar o proveer toda clase que herede de 'InventarioDbTable' (Ver implementación en la figura \ref{fig:figura18}).
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.7]{Graphics/Capitulo 3/Definicion clase abstracta InventarioDBTable.png}
    \caption{Definición de la clase abstracta 'InventarioDbTable'}
    \label{fig:figura18}
\end{figure}

Al crear una clase que hereda de InventarioDbTable, ya que los parámetros 'tableName' y 'primaryKeysWhere' son obligatorios, Dart exigirá que en el constructor de las clases herederas se llame al constructor de su padre
y provea estos dos parámetros mediante la palabra reservada de Dart 'super' y la invocación con los paréntesis, haciendo inclusión de dichos datos mediante el uso de los parámetros de nombre de Dart. Por otra parte, hay una propiedad o 'getter' y un método en la clase 'InventarioDbTable' que al
una clase heredar de esta clase abstracta, Dart te exigirá implementar en la clase heredera. El getter se llama 'primaryKeysWhereArgs' y el método se llama 'toMap()' y junto con los demás parámetros y la definición de la tabla en SQLite, se tiene todo lo necesario para que se ejecute automáticamente la inserción, actualización y eliminación sobre esta nueva tabla.
\\\\
\textbf{tableName}\\
Este parámetro es para establecer una conexión directa con la tabla que representa el modelo. Debe ser el nombre exacto de la tabla que se declare en sqlite.
\\\\
\textbf{toMap()}\\
Este método por convenio debe devolver un Map<String, dynamic> que contenga en sus 'keys' los nombres exactos de los campos de la tabla sqlite que se declaró y en los 'values', los valores asociados que deben ser del mismo tipo que sus campos respectivos declarados en la tabla sqlite asociada.
Este método se usa para la inserción y la actualización.
\\\\
\textbf{primaryKeysWhere} y \textbf{primaryKeysWhereArgs}\\
A la hora de hacer consultas con sqflite, estas se declaran de la forma:
\begin{mdframed}
    database.query(tableName, where: "$ $idPredio = ? AND noEdificio = ?", whereArgs: [predio.idPredio, edificio.noEdificio]);
\end{mdframed}
El objetivo es entregar en este formato: String y List<dynamic> respectivamente las claves primarias de la nueva tabla. Para una idea más clara, en la figura \ref{fig:figura19} se tiene la implementación que
hace la clase 'Encuestador' del Modelo de la clase abstracta 'InventarioDbTable'
\\\\
\begin{figure}[h]
    \centering
    \includegraphics[]{Graphics/Capitulo 3/implementacion_InventarioDBTable.png}
    \caption{Implementación de la clase abstracta 'InventarioDbTable' por la clase 'Encuestador'}
    \label{fig:figura19}
\end{figure}


Completando esto y por supuesto la declaración de la tabla correspondiente en SQLite se tendrá una nueva entidad integrada en el Modelo de Datos
\\
% \\\\
% \section{Conclusiones del capítulo}